# 操作系统
## 1. 用户态和内核态的区别
- 双模态操作将操作系统分为用户态和内核态
   - 用户态下只能执行普通的指令，进程只能访问分配给它的寄存器和内存，使用用户栈，一般用户程序和操作系统程序都运行在用户态下面
   - 内核态可以执行一些特权指令，访问系统的所有资源，可以直接操作和管理硬件设备，使用内核栈，操作系统的内核程序运行在内核态
- **用户态和内核态的切换**在以下三种情况下发生：
   - 系统调用
   - 异常
   - 外部设备的终端

## 2. 进程和线程
### 2.1 进程和线程的区别

- 进程是操作系统中**资源分配的最小单位**，线程是操作系统中**调度的最小单位**。
- 进程包含了一系列的**资源和可执行的指令**，包括
   - 程序代码
   - 程序计数器
   - 寄存器
   - 数据区：堆和栈
      - 堆包含动态分配的一系列变量
      - 栈包含了一系列局部变量，函数参数和返回地址
- 线程有自己**单独的执行栈和局部变量的静态存储区**，但是和同一个进程中的其他线程**共享进程中的资源**，不拥有独立的系统资源
   - 线程没有独立的虚拟地址空间，虚拟地址空间是一个进程中的所有线程共享的
- 一个进程中的多个线程可以**并发执行，开销小，切换快，线程可以看作是一种轻量级的进程**

### 2.2 并行和并发的区别

- 多个进程同时在处理器中执行是**并行**，并发是一个进程的多个线程一起执行时并发。
- **并发**是一个处理器同时处理多个任务，是逻辑上的同时发送，并行是多个处理器同时处理多个任务

### 2.3 跨进程间交流的方式

- 有五种，分别是共享内存，消息队列，信号量，管道和套接字
   - 管道(匿名管道)：是父子进程和通信进程之间的通信方式，Linux Shell中的 ｜ 就是一种管道
   - **有名管道**：任意进程间可以通信。严格遵守FIFO（先进先出）原则，并以磁盘文件的方式存在
   - 信号量：使得进程之间可以知道某件事情发生了
      - 也可以是一个计数器，用于进程之间的同步，**避免发生竞争**的关系
   - 消息队列：一系列“消息”构成的链表队列，满足FIFO，可以存储比较多的信息
   - 共享内存：最有用的进程间通信方式
      - 多个进程可以访问同一块内存地址空间
      - 不同的进程可以及时看到其他进程对共享区域的操作
      - 共享内存也有一定的同步操作
   - 套接字：TCP/IP通信方式，客户端与服务器端进程之间的网络通信。简单的说：不同主机进程之间用套接字中的相关函数完成通信过程

### 2.4 进程的状态

- 进程有new、wait、ready、running和terminate等状态，其中running可以切换到ready和wait，wait可以切换到ready但是不能直接变成running
- 系统调用wait()
   - 通过wait**父进程可以等待子进程结束**，wait调用会返回进程的状态信息和结束进程的pid
      - 这使得父进程可以等待并回收子进程的资源

      - 父进程一旦调用了`wait()`就立即**阻塞自己**，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个子进程出现并结束为止

   - **子进程中止而父进程尚未调用wait**就会使得子进程变成一个**僵尸进程**(zombie process)

   - **父进程中止而没有调用wait**就会产生一个**孤儿进程**(orphan process)
- fork：创建进程的系统调用
   - `int pid1 = fork();`
      - 事实上就是把当前进程分出了一个新的子进程，一个程序变成了两个进程，其中一个是父进程一个是子进程

      - 一个进程调用`fork()`函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己

   - 返回值是一个pid1，从系统调用fork中返回的时候，两个进程除了返回值pid1不同以外具有完全相同的用户级上下文，子进程中pid1为0，父进程中pid1的值就是子进程的pid

### 2.5 进程的调度方法

- FCFS，SJF，优先级调度，时间片轮转，多级队列调度等等

### 2.6 同步与互斥

- 同步是指多个进程按照一定的顺序执行，进程之间通过一系列方式进行通信
- 互斥是指两个进程不能同时访问某个资源，造成互斥的关系

### 2.7 死锁产生的必要条件与解决方法

- 死锁产生的条件：资源访问互斥、占有并等待、资源不可被抢占、循环等待
- 死锁的解决方法：
   - 预防死锁
   - 避免死锁
   - 检测死锁

## 3. 内存
### 3.1 分页管理和分段管理

- 操作系统对内存的管理分为分页管理和分段管理，分页管理是一维的地址空间，而分段空间的地址是二维的，即需要段号和段偏移才能知道
- 页的大小是固定不变的，但是段的大小可以发生变化
- 分段的出现主要是使程序和数据可以被划分为**逻辑上独立的地址空间**，有助于共享和保护；而分页主要是为了实现虚拟内存，获得更大的地址空间

**3.2 虚拟内存**

- 用一部分外存作为内存的扩充，使得逻辑内存比物理内存要大，采用按需调页，虚拟内存的基本思路：只将一部分正在运行的程序放入内存中，将逻辑内存和物理内存分开
   - 请求调页Demand Paging 按需要调取页，请求页式管理

   - 请求段式管理 Demand Segmentation

   - 局部性原理：空间局部性和时间局部性

   - 虚拟内存的空间比物理地址的空间要大

- 一个进程的地址空间中，从高到低依次是栈、堆、数据和代码区，再往外的高地址空间是操作系统的内核和环境变量和参数

## 4. Linux线程模型

- 线程分为用户级线程和内核级线程
- 多线程的常用模型有这样几种：
   - 多对一模型：映射多个用户级线程到一个内核线程，线程管理是由用户空间的线程库完成的，如果一个线程执行阻塞系统调用，那么整个进程都要阻塞，因为任意时间只有一个线程可以访问内核，所以不能并行运行
   - 一对一模型：每个用户线程映射到一个内核线程中，该模型使得一个线程阻塞的时候其他线程可以正常执行，因此可以并行运行，这种模型的缺点是创建一个用户线程就要有相应的内核线程，因此系统的性能可能会受影响，因此会规定允许创建内核线程数量的上限，Linux系统和Windows系统都采用了一对一模型
   - 多对多模型：每个用户线程映射到多个内核线程上
- Linux是一个多任务多用户的操作系统，进程是由正文段、用户数据段和系统数据段、堆栈段组成的动态实体，Linux中使用一个叫做**task_struct的结构体**来管理一系列进程，这些结构体在Linux的内核中组成一个双向链表，并且有一系列的指针结构，Linux中采用POSIX标准的pthread库来创建、激活、撤销线程
- 上下文切换：
   - 当**切换到另一个进程的时候，系统必须要保留上一个进程的状态，同时又载入新进程的状态**


## 5. I/O

- 操作系统中不同的I/O模型主要分为：
   - 同步IO和异步IO
      - 同步是指发送一个请求，等待返回，再发送下一个请求，同步可以避免出现死锁，脏读的发生
      - 异步是指发送请求之后不等待返回直接发送下一个请求，可以提高效率保证并发
   - 阻塞IO和非阻塞IO
      - 阻塞就是当一个线程在发出IO请求时，会阻塞直到IO请求完成之后再进行后面的操作，也就是要等IO完成才能仅需
      - 非阻塞指的是当线程从某通道进行读写数据时，若没有数据可用时，该线程会去执行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道
   - 其中同步阻塞IO称为BIO，同步非阻塞IO称为NIO，异步非阻塞IO称为AIO
- BIO是同步阻塞IO，数据的读写必须阻塞在一个线程里面完成，在读写完成之前该线程处于阻塞状态，是面向流传输的
- NIO是同步非阻塞IO，是面向缓冲区的，会有一个线程进行轮训不断对每个IO操作进程轮询，如果IO完成就执行对应的操作
   - NIO的三个核心概念是通道，缓冲区和选择器
   - 缓冲区是一个暂存IO数据的数组，通道用来沟通线程和缓冲区进行读写，选择器可以使一个线程监视多个通道，在某个通道对应的缓冲区没有数据的时候进行切换
- AIO是异步非阻塞IO，也就是不阻塞并且也不需要进行同步
- 应用场景
   - BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。
   - NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。
   - AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持

# 计算机网络
## 1. TCP协议
- TCP是面向连接，通过数据流传输数据，支持点对点连接和全双工通信的可靠传输层协议
### 1.1 建立连接与三次握手
TCP建立连接的时候需要经过“三次握手”的过程，保证每一方都知道对方的存在，允许双方协商一些参数，能够对运输实体资源进行分配，以A和B两个计算机进行通信为例，三次握手的过程如下

- 第一次握手：A向B发送建立连接的请求
- 第二次握手：B收到请求之后如果同意，就给A发送同意的请求
- 第三次握手：A收到B的同意请求，告诉B收到了B的同意请求

- 三次握手建立连接使得双方都能确定自己的接收发送数据的能力正常，可以建立可靠的连接了

### 1.2 断开连接与四次挥手
在TCP释放连接的时候需要进行四次握手，具体的步骤是：

- A要断开TCP连接的时候通知B，发送一个释放报文
- B收到报文之后发出确认，发送给A
- 若B已经没有需要向A发送的数据就**通知A进行释放**
- A收到通知后需要发出确认，等待一段时间之后关闭连接

- 断开连接需要四次挥手的原因是，并不是立马就断开TCP连接，具体什么时候断开TCP连接需要看应用层的情况，因此在需要断开的时候再发送一次，而之前就是让对方做好准备而已。

### 1.3 TCP协议的可靠性保证

- TCP的数据报发送给网络层之后依靠网络层发送到网络中去，然而IP协议是不可靠的，只能尽全力发送，因此TCP采取了一些措施来保证传输的可靠性，主要有
   - **序号**：TCP的头部用序号字段来表明数据段的顺序
   - **确认号**：在TCP报文的头部携带，告诉对方下一个希望收到的报文段的序号
   - 重传：在超时或者收到冗余ACK的时候会进行重传
   - 滑动窗口

l  **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
l  **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
l  **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
l  **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
l  **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议

### 1.4 流量控制和拥塞控制

- TCP协议的**滑动窗口可以实现流量控制和可靠性的保证**，使得发送方的发送速率和接收方的接受速率相匹配，接收方根据自己甚于缓冲区的大小来调整发送方发送窗口的大小
### 1.5 TCP粘包

- TCP粘包就是指发送方发送**的若干包数据到达接收方时粘成了一包**，从接收缓冲区来看，**后一包数据的头紧接着前一包数据的尾**，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方

## 2. HTTP协议

- HTTP是超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法
- HTTP是面向文本的，因此在报文中的每个字段都是ASCII码串，因此各个字段的长度是不确定的，每个报文有三个部分组成：
   - 开始行：用于区分是请求报文还是响应报文，请求报文中叫做**请求行**，响应报文中叫做**状态行**，以回车换行结尾
      - 请求行有**方法类型、URL和HTTP协议的版本**，方法就是GET、POST、PUT、DELETE等等
         - GET一般用于信息的获取，POST一般用于从服务器上获取数据
         - GET传送的数据量比较小，POST可以传输的数据量比较大
      - 响应报文中的状态行有版本、状态码和短语

   - 首部行：可以有若干行，传输一些信息，用**字段名+空格+value+回车换行**的形式存储

   - 实体主体：请求一般没有，响应中可能会有

- 1.0版本的HTTP协议增加了可传输内容的格式，支持图片、音视频的传播
### 2.1 HTTP1.1

- 早期的HTTP协议，在1.0版本上进行了改进，增加了**持续连接、节约带宽、HOST域、管道机制、分块传输编码**等功能。
- HTTP1.1协议可以进行**流水线式的工作**，也可以进行非流水线式的工作
   - 流水线工作是指客户收到HTTP响应报文之前就能接着发送新的请求，可以连续发送HTTP响应，客户访问所有的对象只需花一个RTT时间，流水线的工作方式使得**TCP连接中的空闲时间减少**
### 2.2 HTTP 2.0

- HTTP2.0大幅度提高了web的性能，完全兼容HTTP1.1的基础上，进一步减少了网络延迟，实现了低延迟高吞吐，HTTP2.0有如下特性：
   - 二进制分帧：改进传输性能，在HTTP和TCP之间增加一个**二进制分帧层，将原本的文本传输变成了使用二进制格式编码后进行传输**
   - 头部压缩：如果header携带cookie的话每次都要重复传输很多字节，这是一笔很大的开销
   - 多路复用：通过二进制分层，HTTP2.0可以在共享TCP连接的基础上同时发送请求和相应，HTTP被分成独立的帧而不影响原本的语义，可以被多路复用发送之后重新组装，提高了传输性能
   - 请求优先级：交叉传输的帧又设置了一定的优先级
   - 服务器推送：服务器可以对一个客户端请求发送多个相应，服务器向客户端推送资源无需客户端明确的请求。
### 2.3 HTTP和HTTPs

- HTTPs就是有SSL外壳的HTTP协议，SSL是**安全套接字层Security Socket Layer，**HTTPS是一种通过计算机网络进行**安全通信**的传输协议，经由HTTP进行通信，利用SSL/TLS建立**全信道，加密数据包**。HTTPS使用的主要目的是提供对网站服务器的**身份认证**，同时**保护交换数据的隐私与完整性**。
- 总的来说就是比HTTP更安全，有身份认证，数据加密，隐私保护等功能。
- HTTPs的加密中，**对传输数据的加密是对称加密，而在证书验证的时候使用的是非对称加密**，因为**非对称加密的加密解密过程非常复杂，而传输数据由于其及时性，不能进行特别复杂的加密，所以数据传输的过程中使用的是对称加密**
### 2.4 websocket

- websocket是一种web浏览器和服务器之间的全双工通信协议，其中web客户端一旦和服务器建立连接，那么在通信过程中，全部的数据通信**都通过这个TCP**连接进行，通信过程中可以发送JSON、XML和HTML等各种格式的数据
- websocket使用HTTP来建立连接，并且不能通过中间人转发，必须是直接连接，建立连接之后使用有序的数据帧来传送数据

## 3. Cookie和Session

- 二者都是用来跟踪浏览器用户身份的会话方式
### 3.1 Cookie的工作原理

- 浏览器第一次发送请求到服务器端的时候，服务器端创建包含用户信息的Cookie，然后将该Cookie发送到浏览器端，浏览器再次访问服务器端的时候会携带由服务器端创建的Cookie，服务端可以通过Cookie来区分不同的用户
### 3.2 Session的工作原理

- 浏览器第一次发送请求到服务器端的，服务端创建一个session同时又会创建一个cookie然后将这个cookie发送到浏览器端，浏览器发送第N次请求到服务端的时候，就会携带name为JSESSIONID的cookie对象
- 服务端可以根据name为JSESSIONID的cookie来区分不同的用户
   - 如果这个ID不存在，就说嘛浏览器已经被关闭或者更换，返回第一步重新创建
   - 如果存在就根据sessionid去寻找session，存在的时候返回session对象
- 基于session实现的网站所有的数据都保存在服务器上，每次浏览器要数据了就发送sessionid过去，服务端根据sessionid来判断用户的数据标志，以确定用户是否登陆或者具有某种权限。
### 3.3 二者的区别

- 最核心的区别是cookie保存在客户端而session保存在服务端
   - cookie容易被中间人攻击，安全性较低
   - session对服务器的压力较大，考虑性能应该使用cookie

## 4. OSI七层模型与TCP/IP架构
### 4.1 OSI七层模型

- OSI七层模型是最传统和经典的计算机网络体系架构模型，OSI模型从上到下分为七层，分别是物理层、数据链路层、网络层、运输层表示层、会话层和应用层，每一层都有不同的作用和相应的协议，但是OSI七层模型是一种非常理想化的模型
- 现实中用的比较多的还是TCP/IP架构，原本是Linux/Unix下的一个网络通信栈，比OSI七层模型简单，它只有四层，分别是网络接口层，Internet层、传输层和应用层。
### 4.2 TCP/IP协议族

- TCP/IP协议族是因特网的基础，这个协议族包括了很多别的协，比较重要的有SLIP、PPP、IP、ICMP、ARP、TCP、UDP、FTP、DNS和SMTP等等，也叫做互联网协议族，提供点对点的连接机制
- **协议族是一组协议的集合，协议栈是一系列协议的实现**，TCP/IP就是一个协议族，而Windows上用C语言实现了TCP/IP协议的具体内容，那么就是一个协议栈，关系就好比类和对象。

## 5. 往浏览器输入网址之后

- 先要进行**DNS的解析**，按顺序查找浏览器缓存，操作系统缓存和路由器缓存，找不到的话再向本地域名服务器和外面的域名服务器发起递归查询和迭代查询
- 建立TCP连接：查到对应的IP地址之后和对应的服务器建立TCP连接
- 浏览器发送HTTP请求，服务器解析处理HTTP请求并返回相应的内容
- 浏览器收到服务器返回的内容之后渲染出对应的页面
